/*! \file bcuser.h */
/****************************************************************
 * File - bcuser.h 
 *
 * User header file for accessing the bc635 pci module
 *
 *
 ***************************************************************/

#ifndef _BCUSER_H_
#define _BCUSER_H_

#include <stdio.h>
#include <time.h>
#include <stdint.h>
#include "bc635.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef struct BC_PCI_STRUCT* BC_PCI_HANDLE;
typedef void (*BC_PCI_INT_HANDLER)(BC_PCI_HANDLE hBC_PCI, int32_t dwSource);

#if 0
typedef struct
{
    WD_INTERRUPT Int;
    HANDLE hThread;
    WD_TRANSFER Trans[3];
    BC_PCI_INT_HANDLER funcIntHandler;
} BC_PCI_INT_INTERRUPT;
#endif

/**
 * stfp_tm_time - Referecned when reading DECIMAL/BCD time. 
 */
struct  stfp_dec_tm {
    uint16_t dec_year;
    uint16_t dec_day;
    uint8_t  dec_hour;
    uint8_t  dec_min;
    uint8_t  dec_sec;
};
/**
 * stfp_time - Referecned 
 */
struct stfp_time {
    struct  tm     tm;     /**< Standard unix timestruct.       */     
    int32_t        usec;   /**< microseconds 0 - 999999         */
    int32_t        hnsec;  /**< hundreds of nanosecods 0 - 9    */
    int32_t        status; /**< status of time read.            */        
};
/**
 * Structure returned from a typical extended time read when using
 * UNIX time. 
 */
struct stfp_timeval {
    /** 
     * Standard unix timespec which returns seconds since epoch
     * and nanoseconds.
     */  
    struct timespec   tv;
    /**
     * the time0 register stores hundreds of nanoseconds. 
     */
    int32_t           hnsec;
    /**
     * status of time frequency processor 
     * Bit 1: Tracking (T)
     *     0: Locked To Selected Reference
     *     1: Flywheeling (Not Locked)
     *
     * Bit 2 Phase (P)
     *     0: < X Microseconds
     *     1: > X Microseconds
     *     X = 5 (Mode 0) 
     *     X = 2 (All Other Modes)
     *
     * Bit 3 Frequency (F)
     *     0: < 5 x 10-8
     *     1: > 5 x 10-8
     */
    int32_t           status;
};
/**
 * Used to control the periodic output. 
 * The PPO signal is generated by dividing down a 1 MHz clock, 
 * synchronous to the 10 MHz oscillator. The periodic output 
 * frequency ranges from 250 kHz (n1 = n2 = 2) to less than 1 Hz. 
 * The frequency isdetermined by the relationship:
 *               Frequency = 1,000,000 / (n1 * n2) Hz
 */
struct periodic {
    /** TRUE = sync periodic to 1pps */
    uint8_t  sync1pps;
    /** divider n1 0:65535 */  
    uint16_t n1;
    /** divider n2 0:65535 */ 
    uint16_t n2;
};

/* Additional Structures to interpret GETDATA command results */
/**      GETDATA_UTCINFO 0x18 */
struct gd_utcinfo {
    uint8_t  enable;
    char     leapsec;
    char     leapevt;
    uint32_t evttime;
};
/** GETDATA_TCGENOFF  0x1C */
struct tcgenoffset {
    uint16_t genoff; /**< local offset -16 to +16 Hours       */
    uint8_t  genflg; /**< flag: 1: half_hour, 0: no_half_hour */
};

/** GETDATA_LOCTMOFF  0x1D */
struct loctmoffset {
    uint16_t locoff; /**< Generator offset -16 to +16 Hours   */
    uint8_t  locflg; /**< flag: 1: half_hour, 0: no_half_hour */ 
};

/** GETDATA_LEAPSEC   0x1E */
struct leapseconds {
    char     ls_flag; /**< 1: Insertion, -1: Deletion, 0: Disable */
    uint32_t leap_tm; /**< Leap Event Time - unix format          */
};

/*      GETDATA_FWVER   0x1F */
struct gd_fwversion {
    uint8_t  vmajor; /**< major version number */
    uint8_t  vminor; /**< minor version number */ 
    uint8_t  month;  /**< month (1 - 12) */
    uint8_t  day;    /**< day (1 - 31 ) */ 
    uint16_t year;   /**< year (e.g. 1994) */
};

/*
 * Modified 03-Mar-13, found better source. 
 * Response to 0x23 command. 
 */
/**
 * Data refering to how the internal oscillator is setup and diciplined.
 */
typedef struct _OscData {
    uint8_t  disctl;    /**< Disciplining Enable/Disable  */
    uint8_t  phasectl;  /**< phase control Enable/Disable */
    uint16_t phasestep; /**< */
    int16_t  DisGain;   /**< Disciplining Gain           */
    int32_t  con;       /**< Not sure what this is.          */ 
} OscData;
typedef struct _TimeData {
    uint8_t  mode;      /**< Selected Reference mode */
    int8_t   tmformat;  /**< Time format (i.e. bin or bcd) */
    uint16_t year;      /**< Current year data */
    int8_t   gpstmfmt;  /**< GPS or UTC time format (0=UTC, 1=GPS) */
    int8_t   leapsec;   /**< Current leap second count */
    int8_t   leapevt;   /**< Current leap second event type (1=ins,0=no,-1=del) */
    int16_t  leapevttm; /**< Scheduled time for leap second event */
    int16_t  locoff;    /**< Local time offset */
    int8_t   lhlfhr;    /**< Local time offset half hour flag */
    int32_t  propdelay; /**< Propgation delay */
    int8_t   dlight;    /**< IEEE Daylight Savings Flag  */
    int8_t   localt;    /**< Local Time Flag Enable/Disable */
} TimeData;


typedef struct BC_PCI_STRUCT
{
   /** the file descriptor, the device is setup a a character driver */
    int    fd; 
} BC_PCI_STRUCT;


typedef struct _TimeCodeData {
    int8_t  format;     /**< Time Code Decode Type */
    int8_t  modulation; /**< Time Code Decode Modulation */
    int8_t  gencode;    /**< Time Code Generator Type */
    short   genoffset;  /**< Time Code Generator Offset */
    int8_t  ghfhr;      /**< Time Code Gen Offset half Hour flag 0/1 */
} TimeCodeData;

/**
 * The data structure used in bcGetTimeCodeDataEx to return time code
 * subtype for V2 hardware.
 */
typedef struct _TimeCodeDataEx {
    int8_t  inputFormat;   /**< Time Code Decode Type        */
    int8_t  inputSubType;  /**< Input Time Code SubType      */
    int8_t  modulation;	   /**< Time Code Decode Modulation  */
    int8_t  outputFormat;  /**< Time Code Generator Type     */
    int8_t  outputSubType; /**< Output Time Code SubType     */
    int16_t genoffset;	   /**< Time Code Generator Offset   */
    int8_t  ghfhr;	   /**< Time Code Gen Offset half Hour flag 0/1 */
} TimeCodeDataEx;

typedef struct _OtherData {
    int8_t hbtmode;	/**< Heartbeat/Periodic mode (0=async,1=sync)  */
    uint16_t hbtcnt1;	/**< Heartbeat/Periodic n1  */
    uint16_t hbtcnt2;	/**< Heartbeat/Periodic n2  */
    int8_t   freq;	/**< Current freq output (1,5,10MHz)  */
    int8_t   evtctl;	/**< Enable/Disable events  */
    int8_t   evtsense;	/**< Event trigger on edge (1=falling,0=rising)  */
    int8_t evtlock;    	/**< Enable/Disable event capture lockout  */
    int8_t evtsrc;     	/**< Event trigger source (0=evt,1=hbt)  */
} OtherData;

typedef struct _OtherDataEx {
    int8_t hbtmode;	/**< Heartbeat/Periodic mode (0=async,1=sync)  */
    uint16_t hbtcnt1;	/**< Heartbeat/Periodic n1  */
    uint16_t hbtcnt2;	/**< Heartbeat/Periodic n2  */
    int8_t   freq;	/**< Current freq output (1,5,10MHz)  */
    int8_t   evtctl;	/**< Enable/Disable events  */
    int8_t   evtsense;	/**< Event trigger on edge (1=falling,0=rising)  */
    int8_t   evtlock;	/**< Enable/Disable event capture lockout  */
    int8_t   evtsrc;    /**< Event trigger source (0=evt,1=hbt)  */
    int8_t   evt2ctl;   /**< Enable/Disable event2  */
    int8_t   evt2sense;	/**< Event2 trigger on edge (1=falling,0=rising)  */
    int8_t   evt2lock;	/**< Enable/Disable event2 capture lockout  */
    int8_t   evt3ctl;    	/**< Enable/Disable event3  */
    int8_t   evt3sense;	/**< Event3 trigger on edge (1=falling,0=rising)  */
    int8_t evt3lock;    /**< Enable/Disable event3 capture lockout  */
} OtherDataEx;

typedef struct _EventsData {
    int8_t evtsrc;	/**< Event trigger source (0=evt,1=hbt)  */
    int8_t evtctl;	/**< Enable/Disable events  */
    int8_t evtsense;    /**< Event trigger on edge (1=falling,0=rising)  */
    int8_t evtlock;	/**< Enable/Disable event capture lockout  */
    int8_t evt2ctl;	/**< Enable/Disable event2  */
    int8_t evt2sense;   /**< Event2 trigger on edge (1=falling,0=rising)  */
    int8_t evt2lock;   	/**< Enable/Disable event2 capture lockout  */
    int8_t evt3ctl;	/**< Enable/Disable event3  */
    int8_t evt3sense;   /**< Event3 trigger on edge (1=falling,0=rising)  */
    int8_t evt3lock;    /**< Enable/Disable event3 capture lockout  */
} EventsData;

typedef struct _ModelData
{
    int8_t model1;	/**< Model 'B'  */
    int8_t model2;	/**< Model 'C'  */
    int8_t model3;	/**< Model '6'  */
    int8_t model4;	/**< Model '3'  */
    int8_t model5;	/**< Model '5' or '7'  */
    int8_t model6;	/**< Model 'P'  */
    int8_t model7;	/**< Model 'C'  */
    int8_t model8;	/**< Model 'I'  */
} ModelData;

typedef struct _VerData {
    int8_t byt1;	/**< Version 'D'   */
    int8_t byt2;	/**< Version 'T'   */
    int8_t byt3;        /**< Version '6'   */
    int8_t byt4;	/**< Version '0'   */
    int8_t byt5;	/**< Version '0'   */
    int8_t byt6;	/**< Version '0'   */
    int8_t byt7;	/**< Version 'A,B,C...'  */ 
    int8_t byt8;	/**< Version '.'   */
    int8_t byt9;	/**< Version '1,2,3...'   */ 
    int8_t byt10;	/**< Version '1,2,3...'   */
    int8_t byt11;	/**< Version '1,2,3...'   */
} VerData;

typedef struct _GpsPkt {
    int8_t id;		/**< GPS Packet ID Byte  */
    int8_t len;		/**< GPS Packet Data Length  */
    int8_t *data;	/**< GPS Packet Data Area Pointer  */
} GpsPkt;


/**
 * IRIG TIME CODE SUB TYPE.
 * The sub type is used when calling
 *
 *   bcSetTcInEx (BC_PCI_HANDLE hBC_PCI, BYTE TcIn, BYTE SubType)
 *   bcSetGenCodeEx (BC_PCI_HANDLE hBC_PCI, BYTE GenTc, BYTE SubType)
 */
/*! \enum  PERIODIC OUTPUT  */
enum { PERIODIC_SYNC		= 0x01 };
enum { PERIODIC_NOSYNC		= 0x00 };


/// JAM SYNC CONTROL
enum { JAM_SYNC_ENA		= 0x01 };
enum { JAM_SYNC_DIS		= 0x00 };


/// GPS TIME FORMAT
enum { GPS_TIME_FMT		= 0x01 };
enum { UTC_TIME_FMT		= 0x00 };


/// GPS OPERATIONAL MODE
enum { GPS_STATIC		= 0x01 };
enum { GPS_NONE_STATIC		= 0x00 };


/// LOCAL OFFSET FLAG 
enum { LOCAL_OFF_ENABLE		= 0x01 };
enum { LOCAL_OFF_DISABLE	= 0x00 };

/// YEAR INCREMENT FLAG
enum { YEAR_AUTO_ENA		= 0x01 };
enum { YEAR_AUTO_DIS		= 0x00 };

/// MISCELLANEOUS
enum { CMD_WARMSTART		= 0x01 };

/// CONTROL REGISTER
enum { LOCKOUT_DISABLE		= 0x00 };
enum { LOCKOUT_ENABLE		= 0x01 };
enum { EVENT_INPUT		= 0x00 };
enum { PROGRAM_PERIODIC	= 0x01 };
enum { EVENT_FALLING_EDGE	= 0x00 };
enum { EVENT_RISING_EDGE	= 0x01 };
enum { EVENT_DISABLE		= 0x00 };
enum { EVENT_ENABLE		= 0x01 };
enum { OUT_FREQ_1MHZ		= 0x01 };
enum { OUT_FREQ_5MHZ		= 0x05 };
enum { OUT_FREQ_10MHZ		= 0x0A };

/// INTERRUPTS
enum { INTERRUPT_EVENT		= 0x01 };
enum { INTERRUPT_PERIODIC	= 0x02 };
enum { INTERRUPT_STROBE		= 0x04 };
enum { INTERRUPT_1PPS		= 0x08 };
enum { INTERRUPT_GPS		= 0x10 };
enum { INTERRUPT_EVENT2		= 0x20 };
enum { INTERRUPT_EVENT3		= 0x40 };

/// Choices for bcSetPeriodicDDSSelect()
enum { SELECT_PERIODIC_OUT      = 0x0 };
enum { SELECT_DDS_OUT           = 0x1 };

/// Choices for bcSetDDSDivider()
enum { DDS_DIVIDE_BY_1E0        = 0x0 };
enum { DDS_DIVIDE_BY_1E1        = 0x1 };
enum { DDS_DIVIDE_BY_1E2        = 0x2 };
enum { DDS_DIVIDE_BY_1E3        = 0x3 };
enum { DDS_DIVIDE_BY_1E4        = 0x4 };
enum { DDS_DIVIDE_BY_1E5        = 0x5 };
enum { DDS_DIVIDE_BY_1E6        = 0x6 };
enum { DDS_DIVIDE_BY_1E7        = 0x7 };
enum { DDS_DIVIDE_BY_PREG       = 0xF };

/// Choices for bcSetDDSDividerSource()
enum { DDS_DIVIDER_SRC_DDS      = 0x0 };
enum { DDS_DIVIDER_SRC_MULT     = 0x1 };
enum { DDS_DIVIDER_SRC_100MHZ   = 0x2 };

/// Choices for bcSetDDSSyncMode()
enum { DDS_SYNC_MODE_FRAC       = 0x0 };
enum { DDS_SYNC_MODE_CONT       = 0x1 };

/// Choices for bcSetDDSMultiplier()
enum { DDS_MULTIPLY_BY_1        = 0x1 };
enum { DDS_MULTIPLY_BY_2        = 0x2 };
enum { DDS_MULTIPLY_BY_3        = 0x3 };
enum { DDS_MULTIPLY_BY_4        = 0x4 };
enum { DDS_MULTIPLY_BY_6        = 0x6 };
enum { DDS_MULTIPLY_BY_8        = 0x8 };
enum { DDS_MULTIPLY_BY_10       = 0xA };
enum { DDS_MULTIPLY_BY_16       = 0x10 };


/*! \fn BCUser_SetVerbose 
 * Set the verbosity of the library, used for debugging purposes. 
 * This will also make a call to the driver to increse the dump level 
 * to the system messages file.
 */
void BCUser_SetVerbose(int val);
/**
 * Get the user verbosity setting. 
 */
int  BCUser_GetVerbose(void);

/** Functions to start/stop the device */
BC_PCI_HANDLE bcStartPci(void);
/** Stop - just show that we are done with the driver. */
void  bcStopPci(BC_PCI_HANDLE hBC_PCI);

/// Functions to read/write device registers
uint8_t bcReadReg (BC_PCI_HANDLE hBC_PCI, uint8_t dwOffset, uint32_t* ulpData);
uint8_t bcWriteReg(BC_PCI_HANDLE hBC_PCI, uint8_t dwOffset, uint32_t data);

// Functions to read/write dual port RAM registers
uint8_t  bcReadDPReg (BC_PCI_HANDLE hBC_PCI, uint8_t dwOffset,uint8_t* bpData);
uint8_t  bcWriteDPReg(BC_PCI_HANDLE hBC_PCI, uint8_t dwOffset,uint8_t data);

// Functions to read binary/decimal time
// ulpMin is binary micro seconds
uint8_t  bcReadBinTime(BC_PCI_HANDLE hBC_PCI, uint32_t* ulpMaj, 
		       uint32_t* ulpMin, int8_t* bpstat);
uint8_t  bcReadDecTime(BC_PCI_HANDLE hBC_PCI, struct tm *ptm, 
		       uint32_t* ulpMin, int8_t* bpstat);

// Functions to set binary/decimal time
uint8_t  bcSetBinTime (BC_PCI_HANDLE hBC_PCI, uint32_t newtime);
uint8_t  bcSetDecTime (BC_PCI_HANDLE hBC_PCI, struct tm);

// Functions to request/set the year
uint8_t  bcReqYear (BC_PCI_HANDLE hBC_PCI, uint16_t* year);
uint8_t  bcSetYear (BC_PCI_HANDLE hBC_PCI, uint16_t year);

// Function to read event time
uint8_t  bcReadEventTime (BC_PCI_HANDLE hBC_PCI, uint32_t* ulpMaj, 
			  uint32_t* ulpMin, int8_t* bpstat);

// Function to set the strobe time
uint8_t  bcSetStrobeTime (BC_PCI_HANDLE hBC_PCI, int16_t dMaj, int16_t dMin);

// Functions to request/set the time format
uint8_t  bcReqTimeFormat (BC_PCI_HANDLE hBC_PCI, int8_t* timeformat);
uint8_t  bcSetTimeFormat (BC_PCI_HANDLE hBC_PCI, int8_t tmfmt);

// Functions to configure the hardware
uint8_t  bcSetMode (BC_PCI_HANDLE hBC_PCI, int8_t mode);
uint8_t  bcSetLocOff (BC_PCI_HANDLE hBC_PCI, int16_t offset, int8_t half);
uint8_t  bcSetGenOff (BC_PCI_HANDLE hBC_PCI, int16_t offset, int8_t half);
uint8_t  bcSetPropDelay (BC_PCI_HANDLE hBC_PCI, int32_t value);
uint8_t  bcSetHbt (BC_PCI_HANDLE hBC_PCI, int8_t mode, uint16_t n1, 
		   uint16_t n2);
// Set Time code format in
uint8_t  bcSetTcIn (BC_PCI_HANDLE hBC_PCI, uint8_t TcIn);
uint8_t  bcSetTcInMod (BC_PCI_HANDLE hBC_PCI, int8_t TcInMod);
uint8_t  bcSetGenCode (BC_PCI_HANDLE hBC_PCI, int8_t GenTc);
uint8_t  bcSetLeapEvent (BC_PCI_HANDLE hBC_PCI, int8_t flag, uint32_t leapevt);
uint8_t  bcSetClkSrc (BC_PCI_HANDLE hBC_PCI, int8_t clk);
uint8_t  bcSetGain (BC_PCI_HANDLE hBC_PCI, int16_t gain);
uint8_t  bcSetJam (BC_PCI_HANDLE hBC_PCI, int8_t jam);
uint8_t  bcSetGpsTmFmt (BC_PCI_HANDLE hBC_PCI, int8_t gpsfmt);
uint8_t  bcSetGpsOperMode (BC_PCI_HANDLE hBC_PCI, int8_t gpsmode);
uint8_t  bcSetLocalFlag (BC_PCI_HANDLE hBC_PCI, int8_t flagoff);
uint8_t  bcSetYearAutoIncFlag (BC_PCI_HANDLE hBC_PCI, int8_t yrinc);
uint8_t  bcAdjustClock (BC_PCI_HANDLE hBC_PCI, int32_t cval);
void     bcCommand (BC_PCI_HANDLE hBC_PCI, int8_t cmd);
uint8_t  bcForceJam (BC_PCI_HANDLE hBC_PCI);
uint8_t  bcSyncRtc (BC_PCI_HANDLE hBC_PCI);
uint8_t  bcRtcBatt (BC_PCI_HANDLE hBC_PCI, uint8_t conn);
uint8_t  bcSetDAC( BC_PCI_HANDLE hBC_PCI, uint16_t val);

// Functions to request the card's configuration
uint8_t  bcReqOscData (BC_PCI_HANDLE hBC_PCI, OscData *);
uint8_t  bcReqTimeCodeData (BC_PCI_HANDLE hBC_PCI, TimeCodeData *);
uint8_t  bcReqTimeData (BC_PCI_HANDLE hBC_PCI, TimeData *);
uint8_t  bcReqOtherData (BC_PCI_HANDLE hBC_PCI, OtherData *);
uint8_t  bcReqVerData (BC_PCI_HANDLE hBC_PCI, VerData *);
uint8_t  bcReqModel (BC_PCI_HANDLE hBC_PCI, ModelData *);
uint8_t  bcReqSerialNum (BC_PCI_HANDLE hBC_PCI, uint32_t* serial);
uint8_t  bcReqHardwareFab (BC_PCI_HANDLE hBC_PCI, uint16_t* fab);
uint8_t  bcReqAssembly (BC_PCI_HANDLE hBC_PCI, int16_t* num);
uint8_t  bcReqInputFormat (BC_PCI_HANDLE hBC_PCI,int8_t *TcIn,int8_t *SubType);
uint8_t  bcReqInputModulation (BC_PCI_HANDLE hBC_PCI, int8_t* fmt);
uint8_t  bcReqOutputFormat(BC_PCI_HANDLE hBC_PCI,int8_t *TcOut,int8_t *SubType);
uint8_t  bcReqClockSource (BC_PCI_HANDLE hBC_PCI, uint8_t* src);
uint8_t  bcReqJamSync (BC_PCI_HANDLE hBC_PCI, uint8_t* src);
uint8_t  bcReqLocalTZObs (BC_PCI_HANDLE hBC_PCI, uint8_t* src);
uint8_t  bcReqBatteryStatus (BC_PCI_HANDLE hBC_PCI, uint8_t* src);
uint8_t  bcReqDAC (BC_PCI_HANDLE hBC_PCI, uint16_t* src);
uint8_t  bcReqGain(BC_PCI_HANDLE hBC_PCI, int16_t* src);
uint8_t  bcReqPeriodics (BC_PCI_HANDLE hBC_PCI, struct periodic* src);
uint8_t  bcReqLeap (BC_PCI_HANDLE hBC_PCI, int8_t* val);
uint8_t  bcReqPropDelay (BC_PCI_HANDLE hBC_PCI, int32_t* val);
uint8_t  bcReqGeneratorOffset(BC_PCI_HANDLE hBC_PCI, struct generatorOffset_t* val);
uint8_t  bcReqLocalOffset(BC_PCI_HANDLE hBC_PCI, struct generatorOffset_t* val);
uint8_t  bcReqMode(BC_PCI_HANDLE hBC_PCI, uint8_t* mode);

// Function to request the card's Firmware not configuration space Revision ID
// This is the 8 bit Revision ID in the PCI configuration space
// For version 1 PCI card, the Revision ID is 0x12
// For version 2 PCI card, the Revision ID is 0x20
uint8_t  bcReqRevisionID (BC_PCI_HANDLE hBC_PCI, int8_t* id);
// This is the firmware revision id which is an 7 long int8_t number.
uint8_t  bcReqFirmRevisionID (BC_PCI_HANDLE hBC_PCI, int8_t* id);

// Function to request the time code data extended with V2 hardware support.
// The V2 hardware supports time code sub type. Calling the original function
// bcReqTimeCodeData (with TimeCodeData *) will not return the sub type info.
uint8_t  bcReqTimeCodeDataEx (BC_PCI_HANDLE hBC_PCI, TimeCodeDataEx *pDat);

// Functions to request/send GPS packets (Bc637PCI model only)
uint8_t  bcGPSReq (BC_PCI_HANDLE hBC_PCI, GpsPkt *);
uint8_t  bcGPSSnd (BC_PCI_HANDLE hBC_PCI, GpsPkt *);
uint8_t  bcGPSMan (BC_PCI_HANDLE hBC_PCI, GpsPkt *, GpsPkt *);

// Interrupts functions
uint8_t  bcStartInt(BC_PCI_HANDLE hBC_PCI, BC_PCI_INT_HANDLER pCallback);
void     bcStopInt (BC_PCI_HANDLE hBC_PCI);
uint8_t  bcSetInt(BC_PCI_HANDLE hBC_PCI, int8_t IntVal);
uint8_t  bcReqInt(BC_PCI_HANDLE hBC_PCI, int8_t* Ints);
void     bcIntHandlerRoutine(BC_PCI_HANDLE hBC_PCI, int16_t dwSource);

// Task delay function
void  bcDelay(int16_t ustime);

// ====================================================================
// DDS functions. These functions are only available for V2 hardware.
// On V1 hardware, it always return FALSE.
// ====================================================================
uint8_t  bcSetPeriodicDDSSelect (BC_PCI_HANDLE hBC_PCI, int8_t bSel);
uint8_t  bcSetPeriodicDDSEnable (BC_PCI_HANDLE hBC_PCI, uint8_t bEnable);
uint8_t  bcSetDDSDivider (BC_PCI_HANDLE hBC_PCI, uint8_t bDiv);
uint8_t  bcSetDDSDividerSource (BC_PCI_HANDLE hBC_PCI, uint8_t bSrc);
uint8_t  bcSetDDSSyncMode (BC_PCI_HANDLE hBC_PCI, int8_t bMode);
uint8_t  bcSetDDSMultiplier (BC_PCI_HANDLE hBC_PCI, int8_t bMult);
// dwPeriod is an integer in the range of [0, 0xFFFFFF]
uint8_t  bcSetDDSPeriodValue (BC_PCI_HANDLE hBC_PCI, uint32_t dwPeriod);
uint8_t  bcSetDDSTuningWord (BC_PCI_HANDLE hBC_PCI, uint32_t dwTuneWord);

// The bcSetDDSFrequency automatically sets the periodic/DDS output to
// be DDS output and sets the DDS sync mode to be DDS_SYNC_MODE_FRAC.
// If you want to come back to periodic output, please call function
// bcSetPeriodicDDSSelect to set it to periodic output. You can also
// change sync mode with bcSetDDSSyncMode.
uint8_t  bcSetDDSFrequency (BC_PCI_HANDLE hBC_PCI, double fFreq);

// This function is the extended version of the 'bcSetTcIn()'. It is
// equivalent to bcSetTcIn() when the 'TcIn' is 
//   TCODE_IRIG_A, or TCODE_IRIG_B, or TCODE_IEEE, or TCODE_NASA
// and the 'SubType' is TCODE_IRIG_SUBTYPE_NONE.
// For example, 'bcSetTcIn (bBC_PCI, TCODE_IRIG_B)' is equivalent
// to 'bcSetTcInEx (bBC_PCI, TCODE_IRIG_B, TCODE_IRIG_SUBTYPE_NONE)'.
//
// However, bcSetTcInEx supports the following new codes.
//
//   TCODE_2137, TCODE_IRIG_SUBTYPE_NONE    (2137)
//   TCODE_XR3, TCODE_IRIG_SUBTYPE_NONE     (XR3)
//   TCODE_IRIG_A, TCODE_IRIG_SUBTYPE_Y     (AY - IRIG A with year)
//   TCODE_IRIG_B, TCODE_IRIG_SUBTYPE_Y     (BY - IRIG B with year)
//   TCODE_IRIG_B, TCODE_IRIG_SUBTYPE_T     (BT - IRIG B Legacy TrueTime)
//   TCODE_IRIG_E, TCODE_IRIG_SUBTYPE_NONE  (E  - IRIG E 1000Hz no year)
//   TCODE_IRIG_E, TCODE_IRIG_SUBTYPE_Y     (EY - IRIG E 1000Hz with year)
//   TCODE_IRIG_e, TCODE_IRIG_SUBTYPE_NONE  (e  - IRIG E 100Hz no year)
//   TCODE_IRIG_e, TCODE_IRIG_SUBTYPE_Y     (eY - IRIG E 100Hz with year)
//   TCODE_IRIG_G, TCODE_IRIG_SUBTYPE_NONE  (G  - IRIG G no year)
//   TCODE_IRIG_G, TCODE_IRIG_SUBTYPE_Y     (GY - IRIG G with year)
//
uint8_t  bcSetTcInEx (BC_PCI_HANDLE hBC_PCI, int8_t TcIn, int8_t SubType);

// This function is the extended version of the 'bcSetGenCode()'. It is
// equivalent to bcSetGenCode() when the 'GenTc' is 
//   TCODE_IRIG_B, or TCODE_IEEE
// and the 'SubType' is TCODE_IRIG_SUBTYPE_NONE.
// For example, 'bcSetGenCode (bBC_PCI, TCODE_IRIG_B)' is equivalent
// to 'bcSetGenCodeEx (bBC_PCI, TCODE_IRIG_B, TCODE_IRIG_SUBTYPE_NONE)'.
//
// However, bcSetGenCodeEx supports the following new codes.
//
//   TCODE_2137, TCODE_IRIG_SUBTYPE_NONE    (2137)
//   TCODE_XR3, TCODE_IRIG_SUBTYPE_NONE     (XR3)
//   TCODE_NASA, TCODE_IRIG_SUBTYPE_NONE    (NASA)
//   TCODE_IRIG_A, TCODE_IRIG_SUBTYPE_0     (A0 - IRIG A BCD,CF,SBS)
//   TCODE_IRIG_A, TCODE_IRIG_SUBTYPE_1     (A1 - IRIG A BCD,CF)
//   TCODE_IRIG_A, TCODE_IRIG_SUBTYPE_2     (A2 - IRIG A BCD)
//   TCODE_IRIG_A, TCODE_IRIG_SUBTYPE_3     (A3 - IRIG A BCD,SBS)
//   TCODE_IRIG_A, TCODE_IRIG_SUBTYPE_4     (A4 - IRIG A BCD,YEAR,CF,SBS)
//   TCODE_IRIG_A, TCODE_IRIG_SUBTYPE_5     (A5 - IRIG A BCD,YEAR,CF)
//   TCODE_IRIG_A, TCODE_IRIG_SUBTYPE_6     (A6 - IRIG A BCD,YEAR)
//   TCODE_IRIG_A, TCODE_IRIG_SUBTYPE_7     (A7 - IRIG A BCD,YEAR,SBS)
//   TCODE_IRIG_B, TCODE_IRIG_SUBTYPE_0     (B0 - IRIG B BCD,CF,SBS)
//   TCODE_IRIG_B, TCODE_IRIG_SUBTYPE_1     (B1 - IRIG B BCD,CF)
//   TCODE_IRIG_B, TCODE_IRIG_SUBTYPE_2     (B2 - IRIG B BCD)
//   TCODE_IRIG_B, TCODE_IRIG_SUBTYPE_3     (B3 - IRIG B BCD,SBS)
//   TCODE_IRIG_B, TCODE_IRIG_SUBTYPE_4     (B4 - IRIG B BCD,YEAR,CF,SBS)
//   TCODE_IRIG_B, TCODE_IRIG_SUBTYPE_5     (B5 - IRIG B BCD,YEAR,CF)
//   TCODE_IRIG_B, TCODE_IRIG_SUBTYPE_6     (B6 - IRIG B BCD,YEAR)
//   TCODE_IRIG_B, TCODE_IRIG_SUBTYPE_7     (B7 - IRIG B BCD,YEAR,SBS)
//   TCODE_IRIG_B, TCODE_IRIG_SUBTYPE_T     (BT - IRIG B BCD,CF,SBS - Legacy TrueTime)
//   TCODE_IRIG_E, TCODE_IRIG_SUBTYPE_1     (E1 - IRIG E 1000Hz BCD,CF)
//   TCODE_IRIG_E, TCODE_IRIG_SUBTYPE_2     (E2 - IRIG E 1000Hz BCD)
//   TCODE_IRIG_E, TCODE_IRIG_SUBTYPE_5     (E5 - IRIG E 1000Hz BCD,YEAR,CF)
//   TCODE_IRIG_E, TCODE_IRIG_SUBTYPE_6     (E6 - IRIG E 1000Hz BCD,YEAR)
//   TCODE_IRIG_e, TCODE_IRIG_SUBTYPE_1     (e1 - IRIG E 100Hz BCD,CF)
//   TCODE_IRIG_e, TCODE_IRIG_SUBTYPE_2     (e2 - IRIG E 100Hz BCD)
//   TCODE_IRIG_e, TCODE_IRIG_SUBTYPE_5     (e5 - IRIG E 100Hz BCD,YEAR,CF)
//   TCODE_IRIG_e, TCODE_IRIG_SUBTYPE_6     (e6 - IRIG E 100Hz BCD,YEAR)
//   TCODE_IRIG_G, TCODE_IRIG_SUBTYPE_5     (G5 - IRIG G BCD,YEAR,CF)
//
uint8_t  bcSetGenCodeEx (BC_PCI_HANDLE hBC_PCI, int8_t GenTc, int8_t SubType);

// Function to read event time including the 100 nano seconds count
uint8_t  bcReadEventTimeEx (BC_PCI_HANDLE hBC_PCI, uint32_t* ulpMaj, 
			    uint32_t* ulpMin, uint16_t* ulpNano, 
			    int8_t* bpstat);

// this string is set to an error message, if one occurs
//extern CHAR BC_PCI_ErrorString[]; maher

// ====================================================================
// New functions for event2 and event3 support.
// ====================================================================
uint8_t  bcReadEvent2TimeEx (BC_PCI_HANDLE hBC_PCI, uint32_t* ulpMaj, 
			     uint32_t* ulpMin, uint16_t* ulpNano, 
			     int8_t* bpstat);
uint8_t  bcReadEvent3TimeEx (BC_PCI_HANDLE hBC_PCI, uint32_t* ulpMaj, 
			     uint32_t* ulpMin, uint16_t* ulpNano,
			     int8_t* bpstat);
uint8_t  bcReqOtherDataEx(BC_PCI_HANDLE hBC_PCI, OtherDataEx *);
uint8_t  bcReqEventsData (BC_PCI_HANDLE hBC_PCI, EventsData *);
uint8_t  bcSetEventsData (BC_PCI_HANDLE hBC_PCI, EventsData *);

// This function enables the interrupts specified by the input mask value.
// The function bcStartInt() uses 'IntMask' 0x7F internally. We found that
// with IntMask 0x7F, interrupts were not handled correctly by the driver
// on newer, faster computers. You must pass the mask value corresponding
// to your desired interrupts to have the driver working properly.
uint8_t  bcStartIntEx(BC_PCI_HANDLE hBC_PCI, BC_PCI_INT_HANDLER pCallback, 
		      int16_t IntMask);

// Returns the 100 nano seconds count field
uint8_t  bcReadBinTimeEx (BC_PCI_HANDLE hBC_PCI, uint32_t* ulpMaj, 
			  uint32_t* ulpMin, uint16_t* ulpNano, int8_t* bpstat);
uint8_t  bcReadDecTimeEx (BC_PCI_HANDLE hBC_PCI, struct tm *ptm, 
			  uint32_t* ulpMin, uint16_t* ulpNano, int8_t* bpstat);
uint8_t  SetDriverVerbose(BC_PCI_STRUCT* hBC_PCI, uint8_t val);
uint8_t  GetOutputFrequency( BC_PCI_STRUCT* hBC_PCI, uint8_t *val);
uint8_t  SetOutputFrequency( BC_PCI_STRUCT* hBC_PCI, uint8_t val);
uint8_t  GetIEEE1344Flag( BC_PCI_STRUCT* hBC_PCI, uint8_t *val);
uint8_t  SetIEEE1344Flag( BC_PCI_STRUCT* hBC_PCI, uint8_t val);
uint8_t  bcSetDis(BC_PCI_HANDLE hBC_PCI, uint8_t dis);
uint8_t  bcSoftReset(BC_PCI_HANDLE hBC_PCI);
uint8_t  bcReadControl(BC_PCI_HANDLE hBC_PCI, uint16_t *val);
#ifdef __cplusplus
}
#endif

#endif //_BCUSER_H_
